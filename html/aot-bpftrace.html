<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Ahead-Of-Time compiled bpftrace programs</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="css/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Ahead-Of-Time compiled bpftrace programs</h1>
</header>
<p>This page serves as a design document for bpftrace AOT compilation support. Design is currently a work-in-progress and will be (somewhat) regularly updated.</p>
<h2 id="background">Background</h2>
<ul>
<li>AOT is motivated by the following technical concerns:
<ul>
<li>Shipping/running LLVM onto prod hosts is resource-heavy (binary size, memory consumption)</li>
<li>Time to first trace is slow for dynamic bpftrace b/c we have to do all the AST passes AND setup runtime resources, where for AOT bpftrace we can just do runtime resource setup</li>
<li>Dynamically compiled bpftrace scripts cannot be easily signed</li>
</ul></li>
</ul>
<h2 id="overall-design">Overall design</h2>
<ul>
<li>Ship a fully executable runtime shim with bpftrace</li>
<li>When compiling a AOT bpftrace program:
<ul>
<li>Build the metadata</li>
<li>Build the bytecode</li>
<li>Make a copy of runtime shim and store metadata + bytecode into a special ELF section (this is the final executable)</li>
</ul></li>
<li>When the shim runs, it knows to look inside itself for the metadata + bytecode and start execution</li>
</ul>
<h2 id="current-architecture">Current architecture</h2>
<p><img src="../examples/aot-bpftrace/old-architecture.png" style="width:100.0%" /></p>
<h2 id="proposed-architecture">Proposed architecture</h2>
<p>AST passes:</p>
<p><img src="../examples/aot-bpftrace/old-passes.png" /> =&gt; <img src="../examples/aot-bpftrace/new-passes.png" /></p>
<p>Simplified architecture (some unchanged parts omitted):</p>
<p><img src="../examples/aot-bpftrace/new-architecture.png" style="width:100.0%" /></p>
<p>Key:</p>
<ul>
<li>Green -&gt; added to all codepaths</li>
<li>Orange -&gt; added to AOT compile codepath</li>
</ul>
<hr />
<p>AOT execution:</p>
<p><img src="../examples/aot-bpftrace/aot-execution.png" /></p>
<h2 id="unsolved-problems">Unsolved problems</h2>
<ul>
<li><code>CodegenLLVM</code> relies on runtime state in <code>BPFtrace</code>
<ul>
<li>Async argument IDs (<code>printf_id_</code>, <code>cat_id_</code>, <code>etc</code>)</li>
<li>Codegen for <code>elapsed</code> embeds map FD</li>
<li>Positional parameters are hardcoded into bytecode</li>
<li>Any others?</li>
</ul></li>
<li>Some features rely on per-host properties
<ul>
<li><code>kaddr()</code></li>
<li><code>uaddr()</code></li>
<li><code>cgroupid()</code></li>
<li><del>non-absolute addr <code>uprobe</code> probes</del>
<ul>
<li>uprobes addresses are actually resolved at runtime so it’s portable</li>
</ul></li>
<li>USDT, and <code>watchpoint</code> probes</li>
<li>Any others?</li>
</ul></li>
<li>Generate CO-RE field access instructions
<ul>
<li>Will need to generate some kind of access identifier (eg. <code>1:0:3:4</code>)</li>
</ul></li>
<li>Runtime still use bcc (eg. symbolization) and bcc links LLVM</li>
<li>Punt all loading to libbpf to gain access to CO-RE features?
<ul>
<li>Map creation, map FD fixup, extern symbol resolution</li>
<li>Reason is that some new bpf helpers (bpf_per_cpu_ptr()) require BTF ID to be in immediate operand of certain instructions, and we may not want to redo/maintain that stuff in bpftrace</li>
<li>Another reason is that in the future we may want to link other BPF programs in (like DWARF-based stack walker)</li>
<li>Reasons not to completely switch over to libbpf include:
<ul>
<li>Large amount of bpftrace code modifications</li>
<li>Loss of ability to mock out maps / unit testing</li>
<li>Extra overhead constructing ELF files for libbpf to work with</li>
<li>If there’s ever a bug in libbpf or we need a new feature, we are beholden to distros shipping an updated libbpf. We cannot vendor either as it’s not going to fly with the distros.</li>
</ul></li>
</ul></li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li>Can save metadata into special ELF section; fortunately we don’t need to worry about compatability as an AOT executable is hermetic</li>
<li>Must ship a stubbed (no bytecode) AOT executable that knows to look inside itself for bytecode
<ul>
<li>Should be simple enough with cmake</li>
</ul></li>
<li>Will need to relocate pseudo-map-FDs at runtime to FDs of created maps (see BPF_PSEUDO_MAP_FD in libbpf)</li>
<li>Create <code>RuntimeResources</code> abstraction
<ul>
<li>That:
<ul>
<li>Describes all the runtime resources that need to be setup before a script is run</li>
<li>Can initialize all the resources given a <code>BPFtrace &amp;</code></li>
<li>Can be serialized/deserialized</li>
</ul></li>
<li>Can just be a public field: <code>BPFtrace::runtime_resources_</code>
<ul>
<li>So it can be easily mocked out for tests</li>
<li>So semantic analyser can add resources</li>
</ul></li>
</ul></li>
</ul>
<h2 id="future-goals">Future goals</h2>
<ul>
<li>User can select features to enable in codegen
<ul>
<li>eg. “tell codegen that the target host has XXX feature”</li>
</ul></li>
<li>Emitted bytecode takes advantage of CO-RE to be more compatible on other hosts</li>
</ul>
<hr />
<h2 id="towards-a-functional-prototype">Towards a functional prototype</h2>
<ul class="task-list">
<li><input type="checkbox" disabled="" checked="" />
Eliminate hard-coded map FDs in bytecode<ul>
<li><a href="https://github.com/iovisor/bpftrace/pull/1861">PR #1861</a></li>
</ul></li>
<li><input type="checkbox" disabled="" />
Add AST pass to check for non-portable features<ul>
<li><a href="https://github.com/iovisor/bpftrace/pull/1871">PR #1871</a></li>
</ul></li>
<li><input type="checkbox" disabled="" />
Encapsulate runtime resource requirements</li>
<li><input type="checkbox" disabled="" />
Create serialization/deserialization routines for <code>RuntimeResources</code></li>
<li><input type="checkbox" disabled="" />
Create runtime shim</li>
</ul>
</body>
</html>
