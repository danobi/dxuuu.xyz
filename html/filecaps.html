<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>File capabilities and /proc/&lt;pid&gt;</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="css/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">File capabilities and /proc/&lt;pid&gt;</h1>
</header>
<p>I’ve spent the past few evenings staring at a rather interesting
kernel “bug”. I put “bug” in quotes b/c, spoiler alert, it’s not a
bug.</p>
<p>It all started with an integration test failing due to a
<code>-EACCES</code> return code. Normally I’d assume it’s a bug with
the code under test, but we also happen to cover the same codepath in
unit tests. So a failure when the code was run in a separate binary was
something worth investigating.</p>
<p>The details of the test and test infrastructure aren’t important b/c
I was able to come up with a short reproducer:</p>
<div class="sourceCode" id="function" data-startFrom="1"><pre
class="sourceCode numberSource c numberLines"><code class="sourceCode c"><span id="function-1"><a href="#function-1"></a><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></span>
<span id="function-2"><a href="#function-2"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="function-3"><a href="#function-3"></a></span>
<span id="function-4"><a href="#function-4"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="function-5"><a href="#function-5"></a>  <span class="dt">int</span> fd <span class="op">=</span> open<span class="op">(</span><span class="st">&quot;/proc/self/auxv&quot;</span><span class="op">,</span> O_RDONLY<span class="op">);</span></span>
<span id="function-6"><a href="#function-6"></a></span>
<span id="function-7"><a href="#function-7"></a>  <span class="cf">if</span> <span class="op">(</span>fd <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="function-8"><a href="#function-8"></a>    perror<span class="op">(</span><span class="st">&quot;open&quot;</span><span class="op">);</span></span>
<span id="function-9"><a href="#function-9"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="function-10"><a href="#function-10"></a>  <span class="op">}</span></span>
<span id="function-11"><a href="#function-11"></a></span>
<span id="function-12"><a href="#function-12"></a>  printf<span class="op">(</span><span class="st">&quot;ok</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="function-13"><a href="#function-13"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="function-14"><a href="#function-14"></a><span class="op">}</span></span></code></pre></div>
<pre><code>$ gcc main.c
$ ./a.out                                             # (1)
ok
$ sudo setcap &quot;cap_net_admin,cap_sys_admin+p&quot; a.out   # (2)
$ ./a.out                                             # (3)
open: Permission denied</code></pre>
<p>Basically the above program tries to open
<code>/proc/self/auxv</code> and reports on whether it was successful.
Pretty simple, and that’s all we do in step (1).</p>
<p>Things get more interesting when we get to step (2). For the
unititiated, in step (2) we set a couple file capabilities on the
executable. File capabilities (filecaps) are basically the same thing as
<a href="https://en.wikipedia.org/wiki/Setuid">setuid</a>, except
filecaps operate on capabilities which are much more granular than
setuid’s “root or not”.</p>
<p>More specifically, we add the capabilities to the
<strong>permitted</strong> set. This is an important distinction b/c it
means the executable, when run as an unprivileged process, starts out
with no extra capabilities. However, the process may grant itself any of
the permitted capabilities (ie. “elevate”). Note how the reproducer does
not elevate to any capabilities. In other words, our reproducer is
capability-dumb.</p>
<p>Finally, in step (3) we run the reproducer just like in step (1).
However unlike in step (1), we get <code>-EACCES</code>. And to be
explicit, this is really strange b/c usually programs encouter
<em>less</em> permission errors with more power (ie. capabilities), not
<em>more</em>. Furthermore, the process doesn’t even possess more power
at runtime.</p>
<p>Now we have everything we need for an interesting investigation: a
trivial reproducer and a wildly unexpected result. The stage is set.</p>
<h2 id="odd-ownership">Odd ownership</h2>
<p>I spent some time trying to trace kernel execution with everyone’s
favorite tracer (bpftrace!). Unfortunately, b/c a lot of the interesting
logic was either in the body of a long function or in an inlined
function call, it was difficult to make progress. So I had to fall back
to tried and true <code>printk()</code> debugging.</p>
<p>What followed was a lot of edit-compile-run loops (shoutout to <a
href="https://github.com/amluto/virtme">virtme</a> for making testing
kernels so easy). I won’t bore you with the details, so suffice to say
after a few hours I discovered that <code>/proc/self/auxv</code> was
owned by <code>root:root</code>. And since <code>/proc/self/auxv</code>
has <code>0400</code> permissions, our process running under
<code>daniel:daniel</code> fails the UNIX permission check in
<code>acl_permission_check()</code>.</p>
<p>Christian Brauner <a
href="https://lore.kernel.org/linux-fsdevel/20221019132201.kd35firo6ks6ph4j@wittgenstein/">later
confirms</a> this discovery on the lists.</p>
<p>So <code>-EACCES</code> is explained. But this begs a new question:
why is <code>/proc/self/auxv</code> owned by root?</p>
<h2 id="process-dumpability">Process dumpability</h2>
<p>I’ve looked at procfs internals <a
href="https://dxuuu.xyz/proc-threads.html">before</a> so I had an idea
where to start looking. It took another few hours and a mixture of
<code>printk()</code> and tracing, but I discovered where the procfs
inodes get their owners calculated: <code>task_dump_owner()</code>.</p>
<p>Around the same time (minutes actually), Omar Sandoval kindly <a
href="https://twitter.com/omsandov/status/1582941637705359360">pointed
out</a> on twitter to look at process dumpability.</p>
<p>Process dumpability appears to govern whether or not processes can
have their cores dumped. This seems reasonable – you may not want a
privileged process’s memory to be dumped to disk if it contains
sensitive information.</p>
<p>With the above hint, the search is narrowed down to the following
block:</p>
<div class="sourceCode" id="function" data-startFrom="1848"><pre
class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 1847;"><span id="function-1848"><a href="#function-1848"></a><span class="dt">void</span> task_dump_owner<span class="op">(</span><span class="kw">struct</span> task_struct <span class="op">*</span>task<span class="op">,</span> umode_t mode<span class="op">,</span></span>
<span id="function-1849"><a href="#function-1849"></a>                     kuid_t <span class="op">*</span>ruid<span class="op">,</span> kgid_t <span class="op">*</span>rgid<span class="op">)</span></span>
<span id="function-1850"><a href="#function-1850"></a><span class="op">{</span></span>
<span id="function-1851"><a href="#function-1851"></a>        <span class="op">[...]</span></span>
<span id="function-1852"><a href="#function-1852"></a></span>
<span id="function-1853"><a href="#function-1853"></a>        <span class="cf">if</span> <span class="op">(</span>mode <span class="op">!=</span> <span class="op">(</span>S_IFDIR<span class="op">|</span>S_IRUGO<span class="op">|</span>S_IXUGO<span class="op">))</span> <span class="op">{</span></span>
<span id="function-1854"><a href="#function-1854"></a>                <span class="kw">struct</span> mm_struct <span class="op">*</span>mm<span class="op">;</span></span>
<span id="function-1855"><a href="#function-1855"></a>                task_lock<span class="op">(</span>task<span class="op">);</span></span>
<span id="function-1856"><a href="#function-1856"></a>                mm <span class="op">=</span> task<span class="op">-&gt;</span>mm<span class="op">;</span></span>
<span id="function-1857"><a href="#function-1857"></a>                <span class="co">/* Make non-dumpable tasks owned by some root */</span></span>
<span id="function-1858"><a href="#function-1858"></a>                <span class="cf">if</span> <span class="op">(</span>mm<span class="op">)</span> <span class="op">{</span></span>
<span id="function-1859"><a href="#function-1859"></a>                        <span class="cf">if</span> <span class="op">(</span>get_dumpable<span class="op">(</span>mm<span class="op">)</span> <span class="op">!=</span> SUID_DUMP_USER<span class="op">)</span> <span class="op">{</span></span>
<span id="function-1860"><a href="#function-1860"></a>                                <span class="kw">struct</span> user_namespace <span class="op">*</span>user_ns <span class="op">=</span> mm<span class="op">-&gt;</span>user_ns<span class="op">;</span></span>
<span id="function-1861"><a href="#function-1861"></a></span>
<span id="function-1862"><a href="#function-1862"></a>                                uid <span class="op">=</span> make_kuid<span class="op">(</span>user_ns<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="function-1863"><a href="#function-1863"></a>                                <span class="cf">if</span> <span class="op">(!</span>uid_valid<span class="op">(</span>uid<span class="op">))</span></span>
<span id="function-1864"><a href="#function-1864"></a>                                        uid <span class="op">=</span> GLOBAL_ROOT_UID<span class="op">;</span></span>
<span id="function-1865"><a href="#function-1865"></a></span>
<span id="function-1866"><a href="#function-1866"></a>                                gid <span class="op">=</span> make_kgid<span class="op">(</span>user_ns<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="function-1867"><a href="#function-1867"></a>                                <span class="cf">if</span> <span class="op">(!</span>gid_valid<span class="op">(</span>gid<span class="op">))</span></span>
<span id="function-1868"><a href="#function-1868"></a>                                        gid <span class="op">=</span> GLOBAL_ROOT_GID<span class="op">;</span></span>
<span id="function-1869"><a href="#function-1869"></a>                        <span class="op">}</span></span>
<span id="function-1870"><a href="#function-1870"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="function-1871"><a href="#function-1871"></a>                        uid <span class="op">=</span> GLOBAL_ROOT_UID<span class="op">;</span></span>
<span id="function-1872"><a href="#function-1872"></a>                        gid <span class="op">=</span> GLOBAL_ROOT_GID<span class="op">;</span></span>
<span id="function-1873"><a href="#function-1873"></a>                <span class="op">}</span></span>
<span id="function-1874"><a href="#function-1874"></a>                task_unlock<span class="op">(</span>task<span class="op">);</span></span>
<span id="function-1875"><a href="#function-1875"></a>        <span class="op">}</span></span>
<span id="function-1876"><a href="#function-1876"></a>        <span class="op">*</span>ruid <span class="op">=</span> uid<span class="op">;</span></span>
<span id="function-1877"><a href="#function-1877"></a>        <span class="op">*</span>rgid <span class="op">=</span> gid<span class="op">;</span></span>
<span id="function-1878"><a href="#function-1878"></a><span class="op">}</span></span></code></pre></div>
<p>Line 1853 checks if the inode is a globally accessible directory.
<code>/proc/pid/auxv</code> is a regular file so we enter the body.</p>
<p>Line 1859 then checks for process dumpability. If it’s not globally
dumpable (globally dumpable meaning anyone can read the process’s core
dumps), the procfs inode is set to be owned by <code>root:root</code>.
This decision is returned via <code>ruid</code> and <code>rgid</code>
out-params on lines 1876-1877.</p>
<h2 id="file-capabilities">File capabilities</h2>
<p>Now that we suspect process dumpability is involved, all that’s left
to do is figure out who or what is setting process dumpability. To that
end, we run the following bpftrace script against the reproducer:</p>
<pre><code>$ cat b.bt
kfunc:set_dumpable
/ comm == &quot;a.out&quot; /
{
  printf(&quot;value=%d\n&quot;, args-&gt;value);
  print(kstack);
}

$ sudo bpftrace ./b.bt
Attaching 1 probe...
value=2

        bpf_prog_f61e3e4e5dc2ac1c_set_dumpable+306
        bpf_get_stackid_raw_tp+119
        bpf_prog_f61e3e4e5dc2ac1c_set_dumpable+306
        bpf_trampoline_6442491445_0+71
        set_dumpable+9
        commit_creds+111
        begin_new_exec+1653
        load_elf_binary+1665
        bprm_execve+639
        do_execveat_common.isra.0+429
        __x64_sys_execve+54
        do_syscall_64+92
        entry_SYSCALL_64_after_hwframe+99

^C</code></pre>
<p>Here we see the smoking gun: <code>__x64_sys_execve+54</code>. This
means that dumpability is being set at process creation time. This
smells badly of file capability shenanigans. However for completeness,
we’ll look at <code>commit_creds()</code> which directly calls
<code>set_dumpable()</code>:</p>
<div class="sourceCode" id="function" data-startFrom="466"><pre
class="sourceCode numberSource c numberLines"><code class="sourceCode c" style="counter-reset: source-line 465;"><span id="function-466"><a href="#function-466"></a><span class="dt">int</span> commit_creds<span class="op">(</span><span class="kw">struct</span> cred <span class="op">*</span>new<span class="op">)</span></span>
<span id="function-467"><a href="#function-467"></a><span class="op">{</span></span>
<span id="function-468"><a href="#function-468"></a>        <span class="op">[...]</span></span>
<span id="function-469"><a href="#function-469"></a></span>
<span id="function-470"><a href="#function-470"></a>        <span class="co">/* dumpability changes */</span></span>
<span id="function-471"><a href="#function-471"></a>        <span class="cf">if</span> <span class="op">(!</span>uid_eq<span class="op">(</span>old<span class="op">-&gt;</span>euid<span class="op">,</span> new<span class="op">-&gt;</span>euid<span class="op">)</span> <span class="op">||</span></span>
<span id="function-472"><a href="#function-472"></a>            <span class="op">!</span>gid_eq<span class="op">(</span>old<span class="op">-&gt;</span>egid<span class="op">,</span> new<span class="op">-&gt;</span>egid<span class="op">)</span> <span class="op">||</span></span>
<span id="function-473"><a href="#function-473"></a>            <span class="op">!</span>uid_eq<span class="op">(</span>old<span class="op">-&gt;</span>fsuid<span class="op">,</span> new<span class="op">-&gt;</span>fsuid<span class="op">)</span> <span class="op">||</span></span>
<span id="function-474"><a href="#function-474"></a>            <span class="op">!</span>gid_eq<span class="op">(</span>old<span class="op">-&gt;</span>fsgid<span class="op">,</span> new<span class="op">-&gt;</span>fsgid<span class="op">)</span> <span class="op">||</span></span>
<span id="function-475"><a href="#function-475"></a>            <span class="op">!</span>cred_cap_issubset<span class="op">(</span>old<span class="op">,</span> new<span class="op">))</span> <span class="op">{</span></span>
<span id="function-476"><a href="#function-476"></a>                <span class="cf">if</span> <span class="op">(</span>task<span class="op">-&gt;</span>mm<span class="op">)</span></span>
<span id="function-477"><a href="#function-477"></a>                        set_dumpable<span class="op">(</span>task<span class="op">-&gt;</span>mm<span class="op">,</span> suid_dumpable<span class="op">);</span></span>
<span id="function-478"><a href="#function-478"></a>                task<span class="op">-&gt;</span>pdeath_signal <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="function-479"><a href="#function-479"></a>                <span class="co">/*</span></span>
<span id="function-480"><a href="#function-480"></a><span class="co">                 * If a task drops privileges and becomes nondumpable,</span></span>
<span id="function-481"><a href="#function-481"></a><span class="co">                 * the dumpability change must become visible before</span></span>
<span id="function-482"><a href="#function-482"></a><span class="co">                 * the credential change; otherwise, a __ptrace_may_access()</span></span>
<span id="function-483"><a href="#function-483"></a><span class="co">                 * racing with this change may be able to attach to a task it</span></span>
<span id="function-484"><a href="#function-484"></a><span class="co">                 * shouldn&#39;t be able to attach to (as if the task had dropped</span></span>
<span id="function-485"><a href="#function-485"></a><span class="co">                 * privileges without becoming nondumpable).</span></span>
<span id="function-486"><a href="#function-486"></a><span class="co">                 * Pairs with a read barrier in __ptrace_may_access().</span></span>
<span id="function-487"><a href="#function-487"></a><span class="co">                 */</span></span>
<span id="function-488"><a href="#function-488"></a>                smp_wmb<span class="op">();</span></span>
<span id="function-489"><a href="#function-489"></a>        <span class="op">}</span></span>
<span id="function-490"><a href="#function-490"></a></span>
<span id="function-491"><a href="#function-491"></a>        <span class="op">[...]</span></span>
<span id="function-492"><a href="#function-492"></a><span class="op">}</span></span></code></pre></div>
<p>Line 475 is what we’ve been after. Essentially what
<code>cred_cap_issubset()</code> is checking is if the old capabilities
are a subset of the new capabilities. If so, it means the process has
gained capabilities during an <code>execve(2)</code> and process
dumpability should be adjusted. Again, this checks out b/c the new
process may (or already) have elevated capabilities and could contain
sensitive information going forward.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So we have our answer: we cannot read <code>/proc/self/auxv</code>
when the executable has <em>any</em> filecaps b/c the filecaps makes the
kernel consider the process potentially sensitive.</p>
<p>Although nothing terribly actionable resulted from this
investivation, I nonetheless found this to be an interesting case study
in emergent properties. Each new discovery made sense in isolation.
However, despite each step making sense, the final result remains odd.
And b/c each step makes sense in isolation, I cannot think of a good way
to change the final result without making some piece of the puzzle
<em>not</em> make sense.</p>
<p>I suppose that’s why documentation is a thing.</p>
<p>And by the way, this behavior is actually documented in
<code>proc(2)</code> man page under <code>PR_SET_DUMPABLE</code>.</p>
</body>
</html>
