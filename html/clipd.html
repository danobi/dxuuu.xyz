<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Rewriting clipd</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="css/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Rewriting clipd</h1>
</header>
<p><code>clipd</code> is a distributed clipboard I wrote back in 2017. Distributed in this context means that a server somewhere runs the clipd server and accepts requests from clients to either:</p>
<ul>
<li>Store new data into the clipboard, or</li>
<li>Grab the current data in the clipboard</li>
</ul>
<p>This solved an annoying problem I had back then where I had too many computers (still do, actually) and had difficulty sharing links between them. This was not a very complicated piece of software (I think it took maybe two weekends). Nonetheless, it still bitrot over the years and recently stopped working for reasons I was too lazy to debug. I did, however, take it as a chance to rewrite the code from Python to Rust, along with a bunch of other improvements along the way.</p>
<p>It took about 6-8 hours to do the full rewrite and after having done so, I thought it would be interesting to document the different design choices I’ve made. Put differently, why current-me is better at programming than old-me four years ago.</p>
<h2 id="language-and-framework">Language and framework</h2>
<p>We’ll ignore the client in this section because the client is very simple in both implementations: open a connection, write some bytes, read some bytes, print. The server is more interesting to discuss.</p>
<h4 id="old-server">Old server</h4>
<p>The old server was written in Python and used <a href="https://docs.python.org/3/library/socketserver.html"><code>socketserver.TCPServer</code></a> with <code>socketserver.ThreadingMixIn</code>, meaning each connection was handled in a separate thread.</p>
<h4 id="new-server">New server</h4>
<p>For the new server, I used async Rust with <a href="https://tokio.rs/">tokio</a> and <a href="https://docs.rs/tokio/1.13.0/tokio/net/struct.TcpListener.html"><code>tokio::TcpListener</code></a> on a single thread to drive the event loop.</p>
<h4 id="commentary">Commentary</h4>
<p>Python as a language was an OK choice. Using <code>socketserver</code> is fine as well, thought I might have chosen <code>asyncio</code> if I had to do things over in Python. I’m not sure what the state of asyncio was back then.</p>
<p>I quite like Rust these days. Rust is pretty easy to write and reason about, plus the memory and type safety is extremely appealing for a project I have no intention of ever writing tests for. The extra efficiency from being a compiled language is nice as well. Using an async framework seems like a good choice since clipd is entire I/O bound.</p>
<h2 id="protocol">Protocol</h2>
<p><code>clipd</code> was and still is TCP-based protocol. TCP remains an excellent choice because I really don’t want to deal with an unreliable connection. On top of TCP, we have our own framed protocol. Framing is obviously necessary because TCP is a streaming protocol, not a message based one. And delimiters seems troublesome given we support arbitrary payloads.</p>
<h4 id="old-protocol">Old protocol</h4>
<pre><code>`clipd` communicates over TCP using ASCII encoded data (please don&#39;t hate me,
utf-8 people). The wire format is as follows:

+---+------+-------+
|LEN|HEADER|PAYLOAD|
+---+------+-------+</code></pre>
<p>where:</p>
<ul>
<li><code>LEN</code> is the total number of characters in the message (<code>LEN</code> excluded).</li>
<li><code>HEADER</code> can be either <code>"PUSH"</code> or <code>"PULL"</code> for requests and <code>"OK"</code> or <code>"ERR"</code> for responses</li>
<li><code>PAYLOAD</code> is either empty, contains the clipboard payload, or the error message</li>
</ul>
<h4 id="new-protocol">New protocol</h4>
<pre><code>clipd protocol (request and response):

0       8      16
+-------+-------------------------+
| magic | type | optional payload |
+-------+-------------------------+

The payload, if present:

0     64
+-----+---------+
| len | payload |
+-----+---------+</code></pre>
<p>where:</p>
<ul>
<li><code>magic</code> is a clipd-specific magic value (integer)</li>
<li><code>type</code> is the type of request (integer)</li>
<li><code>len</code> is length of payload</li>
<li><code>payload</code> is opaque series of bytes</li>
</ul>
<h4 id="commentary-1">Commentary</h4>
<p>Thinking about the old protocol now, I have a couple immediate thoughts:</p>
<ul>
<li>Using ASCII is plain bad because UTF-8 is clearly superior</li>
<li><code>LEN</code> is a strange field because any wire protocol usually has a fixed set of fields in the front and length is only needed if there is a variable sized field. Although not wrong, the placement is strange</li>
<li>The text-based <code>HEADER</code> field is extremely strange, as it’s extra bytes and could be replaced by an integer</li>
</ul>
<p>One thing I learned from staring at the output from the old clipd server is that there are a lot of scanners on the internet that will try probing (sending bytes to) any open port on your server. The magic in the new protocol is there to quickly drop invalid requests. The type in the new protocol is now an integer to be more efficient. Similarly, the length field is now only included when necessary.</p>
<h2 id="protocol-parsing">Protocol parsing</h2>
<p>Protocol parsing is, well, parsing the bytes that come over the wire into the protocol we have designed in the previous section. Although this needs to happen in both the server and the client, the process is similar enough in both binaries to describe together.</p>
<h4 id="old-process">Old process</h4>
<p>The raw bytes are both constructed and processed inline with the application level logic. Meaning something like the following:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>req <span class="op">=</span> <span class="bu">str</span>(<span class="bu">len</span>(HDR_PULL)) <span class="op">+</span> HDR_PULL</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>req <span class="op">=</span> <span class="bu">bytes</span>(req, <span class="st">&#39;ascii&#39;</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>resp <span class="op">=</span> _sock_send_recv(...)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>hdr, payload <span class="op">=</span> _parse_resp(resp)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (hdr <span class="op">!=</span> HDR_OK):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">raise</span> ClipdException(payload)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> payload</span></code></pre></div>
<h4 id="new-process">New process</h4>
<p>The new code is structured to have a protocol “library” that hides the details of how the requests and responses are sent over the wire. This “library” is used in both the client and server. The library more or less looks like:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">enum</span> RequestFrame <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// A request to push bytes to the server</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    Push(<span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/// A request to pull the currently stored bytes on the server</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    Pull<span class="op">,</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> RequestFrame <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">async</span> <span class="kw">fn</span> from_socket(socket<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> TcpStream) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>RequestFrame<span class="op">&gt;;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> to_bytes(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>ResponseFrame</code> has an symmetric API except with different enum variants.</p>
<h4 id="commentary-2">Commentary</h4>
<p>The new way is obviously superior looking back after the fact. Mixing protocol level details with the application logic leads to more complexity (not necessarily in this simple application, but the principle still applies) as well as duplicated logic in both client and server. It’s a clear win to separate concerns and share code between the client and server.</p>
<h2 id="operation-in-production">Operation in production</h2>
<p>“Operation” and “production” in this context means “how it’s run” and “on my server”, respectively.</p>
<h4 id="old-way">Old way</h4>
<p>I ran the clipd server binary inside a session of tmux.</p>
<h4 id="new-way">New way</h4>
<p>I run clipd as a systemd system service.</p>
<h4 id="commentary-3">Commentary</h4>
<p>The old way was simpler (not by much) but easier to mess up. For example if the server was restarted I would have to remember to run clipd again.</p>
<p>The new way is clearly better b/c systemd is designed to manage system daemons (among other things). I suspect I didn’t know systemd well enough back then to know to make a systemd service.</p>
<h2 id="final-commentary">Final commentary</h2>
<p>After the rewrite clipd feels much snappier and seems to work well again. I found the process of exploring my old code interesting enough that I spent even more time to write a post. So in a way I suppose I’m doubly glad I finally got around to it.</p>
</body>
</html>
